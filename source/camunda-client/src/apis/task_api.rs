/*
 * Camunda BPM REST API
 *
 * OpenApi Spec for Camunda BPM REST API.
 *
 * The version of the OpenAPI document: 7.14.0
 * 
 * Generated by: https://openapi-generator.tech
 */

use std::rc::Rc;
use std::borrow::Borrow;
#[allow(unused_imports)]
use std::option::Option;

use reqwest;

use super::{Error, configuration};

pub struct TaskApiClient {
    configuration: Rc<configuration::Configuration>,
}

impl TaskApiClient {
    pub fn new(configuration: Rc<configuration::Configuration>) -> TaskApiClient {
        TaskApiClient {
            configuration,
        }
    }
}

pub trait TaskApi {
    fn claim(&self, id: &str, user_id_dto: Option<crate::models::UserIdDto>) -> Result<(), Error>;
    fn complete(&self, id: &str, complete_task_dto: Option<crate::models::CompleteTaskDto>) -> Result<::std::collections::HashMap<String, crate::models::VariableValueDto>, Error>;
    fn create_task(&self, task_dto: Option<crate::models::TaskDto>) -> Result<(), Error>;
    fn delegate_task(&self, id: &str, user_id_dto: Option<crate::models::UserIdDto>) -> Result<(), Error>;
    fn delete_task(&self, id: &str) -> Result<(), Error>;
    fn get_deployed_form(&self, id: &str) -> Result<std::path::PathBuf, Error>;
    fn get_form(&self, id: &str) -> Result<crate::models::FormDto, Error>;
    fn get_form_variables(&self, id: &str, variable_names: Option<&str>, deserialize_values: Option<bool>) -> Result<::std::collections::HashMap<String, crate::models::VariableValueDto>, Error>;
    fn get_rendered_form(&self, id: &str) -> Result<std::path::PathBuf, Error>;
    fn get_task(&self, id: &str) -> Result<crate::models::TaskDto, Error>;
    fn get_tasks(&self, process_instance_id: Option<&str>, process_instance_id_in: Option<&str>, process_instance_business_key: Option<&str>, process_instance_business_key_expression: Option<&str>, process_instance_business_key_in: Option<&str>, process_instance_business_key_like: Option<&str>, process_instance_business_key_like_expression: Option<&str>, process_definition_id: Option<&str>, process_definition_key: Option<&str>, process_definition_key_in: Option<&str>, process_definition_name: Option<&str>, process_definition_name_like: Option<&str>, execution_id: Option<&str>, case_instance_id: Option<&str>, case_instance_business_key: Option<&str>, case_instance_business_key_like: Option<&str>, case_definition_id: Option<&str>, case_definition_key: Option<&str>, case_definition_name: Option<&str>, case_definition_name_like: Option<&str>, case_execution_id: Option<&str>, activity_instance_id_in: Option<&str>, tenant_id_in: Option<&str>, without_tenant_id: Option<bool>, assignee: Option<&str>, assignee_expression: Option<&str>, assignee_like: Option<&str>, assignee_like_expression: Option<&str>, assignee_in: Option<&str>, owner: Option<&str>, owner_expression: Option<&str>, candidate_group: Option<&str>, candidate_group_expression: Option<&str>, candidate_user: Option<&str>, candidate_user_expression: Option<&str>, include_assigned_tasks: Option<bool>, involved_user: Option<&str>, involved_user_expression: Option<&str>, assigned: Option<bool>, unassigned: Option<bool>, task_definition_key: Option<&str>, task_definition_key_in: Option<&str>, task_definition_key_like: Option<&str>, name: Option<&str>, name_not_equal: Option<&str>, name_like: Option<&str>, name_not_like: Option<&str>, description: Option<&str>, description_like: Option<&str>, priority: Option<i32>, max_priority: Option<i32>, min_priority: Option<i32>, due_date: Option<&str>, due_date_expression: Option<&str>, due_after: Option<&str>, due_after_expression: Option<&str>, due_before: Option<&str>, due_before_expression: Option<&str>, follow_up_date: Option<&str>, follow_up_date_expression: Option<&str>, follow_up_after: Option<&str>, follow_up_after_expression: Option<&str>, follow_up_before: Option<&str>, follow_up_before_expression: Option<&str>, follow_up_before_or_not_existent: Option<&str>, follow_up_before_or_not_existent_expression: Option<&str>, created_on: Option<&str>, created_on_expression: Option<&str>, created_after: Option<&str>, created_after_expression: Option<&str>, created_before: Option<&str>, created_before_expression: Option<&str>, delegation_state: Option<&str>, candidate_groups: Option<&str>, candidate_groups_expression: Option<&str>, with_candidate_groups: Option<bool>, without_candidate_groups: Option<bool>, with_candidate_users: Option<bool>, without_candidate_users: Option<bool>, active: Option<bool>, suspended: Option<bool>, task_variables: Option<&str>, process_variables: Option<&str>, case_instance_variables: Option<&str>, variable_names_ignore_case: Option<bool>, variable_values_ignore_case: Option<bool>, parent_task_id: Option<&str>, sort_by: Option<&str>, sort_order: Option<&str>, first_result: Option<i32>, max_results: Option<i32>) -> Result<Vec<crate::models::TaskDto>, Error>;
    fn get_tasks_count(&self, process_instance_id: Option<&str>, process_instance_id_in: Option<&str>, process_instance_business_key: Option<&str>, process_instance_business_key_expression: Option<&str>, process_instance_business_key_in: Option<&str>, process_instance_business_key_like: Option<&str>, process_instance_business_key_like_expression: Option<&str>, process_definition_id: Option<&str>, process_definition_key: Option<&str>, process_definition_key_in: Option<&str>, process_definition_name: Option<&str>, process_definition_name_like: Option<&str>, execution_id: Option<&str>, case_instance_id: Option<&str>, case_instance_business_key: Option<&str>, case_instance_business_key_like: Option<&str>, case_definition_id: Option<&str>, case_definition_key: Option<&str>, case_definition_name: Option<&str>, case_definition_name_like: Option<&str>, case_execution_id: Option<&str>, activity_instance_id_in: Option<&str>, tenant_id_in: Option<&str>, without_tenant_id: Option<bool>, assignee: Option<&str>, assignee_expression: Option<&str>, assignee_like: Option<&str>, assignee_like_expression: Option<&str>, assignee_in: Option<&str>, owner: Option<&str>, owner_expression: Option<&str>, candidate_group: Option<&str>, candidate_group_expression: Option<&str>, candidate_user: Option<&str>, candidate_user_expression: Option<&str>, include_assigned_tasks: Option<bool>, involved_user: Option<&str>, involved_user_expression: Option<&str>, assigned: Option<bool>, unassigned: Option<bool>, task_definition_key: Option<&str>, task_definition_key_in: Option<&str>, task_definition_key_like: Option<&str>, name: Option<&str>, name_not_equal: Option<&str>, name_like: Option<&str>, name_not_like: Option<&str>, description: Option<&str>, description_like: Option<&str>, priority: Option<i32>, max_priority: Option<i32>, min_priority: Option<i32>, due_date: Option<&str>, due_date_expression: Option<&str>, due_after: Option<&str>, due_after_expression: Option<&str>, due_before: Option<&str>, due_before_expression: Option<&str>, follow_up_date: Option<&str>, follow_up_date_expression: Option<&str>, follow_up_after: Option<&str>, follow_up_after_expression: Option<&str>, follow_up_before: Option<&str>, follow_up_before_expression: Option<&str>, follow_up_before_or_not_existent: Option<&str>, follow_up_before_or_not_existent_expression: Option<&str>, created_on: Option<&str>, created_on_expression: Option<&str>, created_after: Option<&str>, created_after_expression: Option<&str>, created_before: Option<&str>, created_before_expression: Option<&str>, delegation_state: Option<&str>, candidate_groups: Option<&str>, candidate_groups_expression: Option<&str>, with_candidate_groups: Option<bool>, without_candidate_groups: Option<bool>, with_candidate_users: Option<bool>, without_candidate_users: Option<bool>, active: Option<bool>, suspended: Option<bool>, task_variables: Option<&str>, process_variables: Option<&str>, case_instance_variables: Option<&str>, variable_names_ignore_case: Option<bool>, variable_values_ignore_case: Option<bool>, parent_task_id: Option<&str>) -> Result<crate::models::CountResultDto, Error>;
    fn handle_bpmn_error(&self, id: &str, task_bpmn_error_dto: Option<crate::models::TaskBpmnErrorDto>) -> Result<(), Error>;
    fn handle_escalation(&self, id: &str, task_escalation_dto: Option<crate::models::TaskEscalationDto>) -> Result<(), Error>;
    fn query_tasks(&self, first_result: Option<i32>, max_results: Option<i32>, task_query_dto: Option<crate::models::TaskQueryDto>) -> Result<Vec<crate::models::TaskDto>, Error>;
    fn query_tasks_count(&self, task_query_dto: Option<crate::models::TaskQueryDto>) -> Result<crate::models::CountResultDto, Error>;
    fn resolve(&self, id: &str, complete_task_dto: Option<crate::models::CompleteTaskDto>) -> Result<(), Error>;
    fn set_assignee(&self, id: &str, user_id_dto: Option<crate::models::UserIdDto>) -> Result<(), Error>;
    fn submit(&self, id: &str, complete_task_dto: Option<crate::models::CompleteTaskDto>) -> Result<::std::collections::HashMap<String, crate::models::VariableValueDto>, Error>;
    fn unclaim(&self, id: &str) -> Result<(), Error>;
    fn update_task(&self, id: &str, task_dto: Option<crate::models::TaskDto>) -> Result<(), Error>;
}

impl TaskApi for TaskApiClient {
    fn claim(&self, id: &str, user_id_dto: Option<crate::models::UserIdDto>) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/task/{id}/claim", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        req_builder = req_builder.json(&user_id_dto);

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn complete(&self, id: &str, complete_task_dto: Option<crate::models::CompleteTaskDto>) -> Result<::std::collections::HashMap<String, crate::models::VariableValueDto>, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/task/{id}/complete", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        req_builder = req_builder.json(&complete_task_dto);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn create_task(&self, task_dto: Option<crate::models::TaskDto>) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/task/create", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        req_builder = req_builder.json(&task_dto);

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn delegate_task(&self, id: &str, user_id_dto: Option<crate::models::UserIdDto>) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/task/{id}/delegate", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        req_builder = req_builder.json(&user_id_dto);

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn delete_task(&self, id: &str) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/task/{id}", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.delete(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn get_deployed_form(&self, id: &str) -> Result<std::path::PathBuf, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/task/{id}/deployed-form", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn get_form(&self, id: &str) -> Result<crate::models::FormDto, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/task/{id}/form", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn get_form_variables(&self, id: &str, variable_names: Option<&str>, deserialize_values: Option<bool>) -> Result<::std::collections::HashMap<String, crate::models::VariableValueDto>, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/task/{id}/form-variables", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = variable_names {
            req_builder = req_builder.query(&[("variableNames", &s.to_string())]);
        }
        if let Some(ref s) = deserialize_values {
            req_builder = req_builder.query(&[("deserializeValues", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn get_rendered_form(&self, id: &str) -> Result<std::path::PathBuf, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/task/{id}/rendered-form", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn get_task(&self, id: &str) -> Result<crate::models::TaskDto, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/task/{id}", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn get_tasks(&self, process_instance_id: Option<&str>, process_instance_id_in: Option<&str>, process_instance_business_key: Option<&str>, process_instance_business_key_expression: Option<&str>, process_instance_business_key_in: Option<&str>, process_instance_business_key_like: Option<&str>, process_instance_business_key_like_expression: Option<&str>, process_definition_id: Option<&str>, process_definition_key: Option<&str>, process_definition_key_in: Option<&str>, process_definition_name: Option<&str>, process_definition_name_like: Option<&str>, execution_id: Option<&str>, case_instance_id: Option<&str>, case_instance_business_key: Option<&str>, case_instance_business_key_like: Option<&str>, case_definition_id: Option<&str>, case_definition_key: Option<&str>, case_definition_name: Option<&str>, case_definition_name_like: Option<&str>, case_execution_id: Option<&str>, activity_instance_id_in: Option<&str>, tenant_id_in: Option<&str>, without_tenant_id: Option<bool>, assignee: Option<&str>, assignee_expression: Option<&str>, assignee_like: Option<&str>, assignee_like_expression: Option<&str>, assignee_in: Option<&str>, owner: Option<&str>, owner_expression: Option<&str>, candidate_group: Option<&str>, candidate_group_expression: Option<&str>, candidate_user: Option<&str>, candidate_user_expression: Option<&str>, include_assigned_tasks: Option<bool>, involved_user: Option<&str>, involved_user_expression: Option<&str>, assigned: Option<bool>, unassigned: Option<bool>, task_definition_key: Option<&str>, task_definition_key_in: Option<&str>, task_definition_key_like: Option<&str>, name: Option<&str>, name_not_equal: Option<&str>, name_like: Option<&str>, name_not_like: Option<&str>, description: Option<&str>, description_like: Option<&str>, priority: Option<i32>, max_priority: Option<i32>, min_priority: Option<i32>, due_date: Option<&str>, due_date_expression: Option<&str>, due_after: Option<&str>, due_after_expression: Option<&str>, due_before: Option<&str>, due_before_expression: Option<&str>, follow_up_date: Option<&str>, follow_up_date_expression: Option<&str>, follow_up_after: Option<&str>, follow_up_after_expression: Option<&str>, follow_up_before: Option<&str>, follow_up_before_expression: Option<&str>, follow_up_before_or_not_existent: Option<&str>, follow_up_before_or_not_existent_expression: Option<&str>, created_on: Option<&str>, created_on_expression: Option<&str>, created_after: Option<&str>, created_after_expression: Option<&str>, created_before: Option<&str>, created_before_expression: Option<&str>, delegation_state: Option<&str>, candidate_groups: Option<&str>, candidate_groups_expression: Option<&str>, with_candidate_groups: Option<bool>, without_candidate_groups: Option<bool>, with_candidate_users: Option<bool>, without_candidate_users: Option<bool>, active: Option<bool>, suspended: Option<bool>, task_variables: Option<&str>, process_variables: Option<&str>, case_instance_variables: Option<&str>, variable_names_ignore_case: Option<bool>, variable_values_ignore_case: Option<bool>, parent_task_id: Option<&str>, sort_by: Option<&str>, sort_order: Option<&str>, first_result: Option<i32>, max_results: Option<i32>) -> Result<Vec<crate::models::TaskDto>, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/task", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = process_instance_id {
            req_builder = req_builder.query(&[("processInstanceId", &s.to_string())]);
        }
        if let Some(ref s) = process_instance_id_in {
            req_builder = req_builder.query(&[("processInstanceIdIn", &s.to_string())]);
        }
        if let Some(ref s) = process_instance_business_key {
            req_builder = req_builder.query(&[("processInstanceBusinessKey", &s.to_string())]);
        }
        if let Some(ref s) = process_instance_business_key_expression {
            req_builder = req_builder.query(&[("processInstanceBusinessKeyExpression", &s.to_string())]);
        }
        if let Some(ref s) = process_instance_business_key_in {
            req_builder = req_builder.query(&[("processInstanceBusinessKeyIn", &s.to_string())]);
        }
        if let Some(ref s) = process_instance_business_key_like {
            req_builder = req_builder.query(&[("processInstanceBusinessKeyLike", &s.to_string())]);
        }
        if let Some(ref s) = process_instance_business_key_like_expression {
            req_builder = req_builder.query(&[("processInstanceBusinessKeyLikeExpression", &s.to_string())]);
        }
        if let Some(ref s) = process_definition_id {
            req_builder = req_builder.query(&[("processDefinitionId", &s.to_string())]);
        }
        if let Some(ref s) = process_definition_key {
            req_builder = req_builder.query(&[("processDefinitionKey", &s.to_string())]);
        }
        if let Some(ref s) = process_definition_key_in {
            req_builder = req_builder.query(&[("processDefinitionKeyIn", &s.to_string())]);
        }
        if let Some(ref s) = process_definition_name {
            req_builder = req_builder.query(&[("processDefinitionName", &s.to_string())]);
        }
        if let Some(ref s) = process_definition_name_like {
            req_builder = req_builder.query(&[("processDefinitionNameLike", &s.to_string())]);
        }
        if let Some(ref s) = execution_id {
            req_builder = req_builder.query(&[("executionId", &s.to_string())]);
        }
        if let Some(ref s) = case_instance_id {
            req_builder = req_builder.query(&[("caseInstanceId", &s.to_string())]);
        }
        if let Some(ref s) = case_instance_business_key {
            req_builder = req_builder.query(&[("caseInstanceBusinessKey", &s.to_string())]);
        }
        if let Some(ref s) = case_instance_business_key_like {
            req_builder = req_builder.query(&[("caseInstanceBusinessKeyLike", &s.to_string())]);
        }
        if let Some(ref s) = case_definition_id {
            req_builder = req_builder.query(&[("caseDefinitionId", &s.to_string())]);
        }
        if let Some(ref s) = case_definition_key {
            req_builder = req_builder.query(&[("caseDefinitionKey", &s.to_string())]);
        }
        if let Some(ref s) = case_definition_name {
            req_builder = req_builder.query(&[("caseDefinitionName", &s.to_string())]);
        }
        if let Some(ref s) = case_definition_name_like {
            req_builder = req_builder.query(&[("caseDefinitionNameLike", &s.to_string())]);
        }
        if let Some(ref s) = case_execution_id {
            req_builder = req_builder.query(&[("caseExecutionId", &s.to_string())]);
        }
        if let Some(ref s) = activity_instance_id_in {
            req_builder = req_builder.query(&[("activityInstanceIdIn", &s.to_string())]);
        }
        if let Some(ref s) = tenant_id_in {
            req_builder = req_builder.query(&[("tenantIdIn", &s.to_string())]);
        }
        if let Some(ref s) = without_tenant_id {
            req_builder = req_builder.query(&[("withoutTenantId", &s.to_string())]);
        }
        if let Some(ref s) = assignee {
            req_builder = req_builder.query(&[("assignee", &s.to_string())]);
        }
        if let Some(ref s) = assignee_expression {
            req_builder = req_builder.query(&[("assigneeExpression", &s.to_string())]);
        }
        if let Some(ref s) = assignee_like {
            req_builder = req_builder.query(&[("assigneeLike", &s.to_string())]);
        }
        if let Some(ref s) = assignee_like_expression {
            req_builder = req_builder.query(&[("assigneeLikeExpression", &s.to_string())]);
        }
        if let Some(ref s) = assignee_in {
            req_builder = req_builder.query(&[("assigneeIn", &s.to_string())]);
        }
        if let Some(ref s) = owner {
            req_builder = req_builder.query(&[("owner", &s.to_string())]);
        }
        if let Some(ref s) = owner_expression {
            req_builder = req_builder.query(&[("ownerExpression", &s.to_string())]);
        }
        if let Some(ref s) = candidate_group {
            req_builder = req_builder.query(&[("candidateGroup", &s.to_string())]);
        }
        if let Some(ref s) = candidate_group_expression {
            req_builder = req_builder.query(&[("candidateGroupExpression", &s.to_string())]);
        }
        if let Some(ref s) = candidate_user {
            req_builder = req_builder.query(&[("candidateUser", &s.to_string())]);
        }
        if let Some(ref s) = candidate_user_expression {
            req_builder = req_builder.query(&[("candidateUserExpression", &s.to_string())]);
        }
        if let Some(ref s) = include_assigned_tasks {
            req_builder = req_builder.query(&[("includeAssignedTasks", &s.to_string())]);
        }
        if let Some(ref s) = involved_user {
            req_builder = req_builder.query(&[("involvedUser", &s.to_string())]);
        }
        if let Some(ref s) = involved_user_expression {
            req_builder = req_builder.query(&[("involvedUserExpression", &s.to_string())]);
        }
        if let Some(ref s) = assigned {
            req_builder = req_builder.query(&[("assigned", &s.to_string())]);
        }
        if let Some(ref s) = unassigned {
            req_builder = req_builder.query(&[("unassigned", &s.to_string())]);
        }
        if let Some(ref s) = task_definition_key {
            req_builder = req_builder.query(&[("taskDefinitionKey", &s.to_string())]);
        }
        if let Some(ref s) = task_definition_key_in {
            req_builder = req_builder.query(&[("taskDefinitionKeyIn", &s.to_string())]);
        }
        if let Some(ref s) = task_definition_key_like {
            req_builder = req_builder.query(&[("taskDefinitionKeyLike", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = name_not_equal {
            req_builder = req_builder.query(&[("nameNotEqual", &s.to_string())]);
        }
        if let Some(ref s) = name_like {
            req_builder = req_builder.query(&[("nameLike", &s.to_string())]);
        }
        if let Some(ref s) = name_not_like {
            req_builder = req_builder.query(&[("nameNotLike", &s.to_string())]);
        }
        if let Some(ref s) = description {
            req_builder = req_builder.query(&[("description", &s.to_string())]);
        }
        if let Some(ref s) = description_like {
            req_builder = req_builder.query(&[("descriptionLike", &s.to_string())]);
        }
        if let Some(ref s) = priority {
            req_builder = req_builder.query(&[("priority", &s.to_string())]);
        }
        if let Some(ref s) = max_priority {
            req_builder = req_builder.query(&[("maxPriority", &s.to_string())]);
        }
        if let Some(ref s) = min_priority {
            req_builder = req_builder.query(&[("minPriority", &s.to_string())]);
        }
        if let Some(ref s) = due_date {
            req_builder = req_builder.query(&[("dueDate", &s.to_string())]);
        }
        if let Some(ref s) = due_date_expression {
            req_builder = req_builder.query(&[("dueDateExpression", &s.to_string())]);
        }
        if let Some(ref s) = due_after {
            req_builder = req_builder.query(&[("dueAfter", &s.to_string())]);
        }
        if let Some(ref s) = due_after_expression {
            req_builder = req_builder.query(&[("dueAfterExpression", &s.to_string())]);
        }
        if let Some(ref s) = due_before {
            req_builder = req_builder.query(&[("dueBefore", &s.to_string())]);
        }
        if let Some(ref s) = due_before_expression {
            req_builder = req_builder.query(&[("dueBeforeExpression", &s.to_string())]);
        }
        if let Some(ref s) = follow_up_date {
            req_builder = req_builder.query(&[("followUpDate", &s.to_string())]);
        }
        if let Some(ref s) = follow_up_date_expression {
            req_builder = req_builder.query(&[("followUpDateExpression", &s.to_string())]);
        }
        if let Some(ref s) = follow_up_after {
            req_builder = req_builder.query(&[("followUpAfter", &s.to_string())]);
        }
        if let Some(ref s) = follow_up_after_expression {
            req_builder = req_builder.query(&[("followUpAfterExpression", &s.to_string())]);
        }
        if let Some(ref s) = follow_up_before {
            req_builder = req_builder.query(&[("followUpBefore", &s.to_string())]);
        }
        if let Some(ref s) = follow_up_before_expression {
            req_builder = req_builder.query(&[("followUpBeforeExpression", &s.to_string())]);
        }
        if let Some(ref s) = follow_up_before_or_not_existent {
            req_builder = req_builder.query(&[("followUpBeforeOrNotExistent", &s.to_string())]);
        }
        if let Some(ref s) = follow_up_before_or_not_existent_expression {
            req_builder = req_builder.query(&[("followUpBeforeOrNotExistentExpression", &s.to_string())]);
        }
        if let Some(ref s) = created_on {
            req_builder = req_builder.query(&[("createdOn", &s.to_string())]);
        }
        if let Some(ref s) = created_on_expression {
            req_builder = req_builder.query(&[("createdOnExpression", &s.to_string())]);
        }
        if let Some(ref s) = created_after {
            req_builder = req_builder.query(&[("createdAfter", &s.to_string())]);
        }
        if let Some(ref s) = created_after_expression {
            req_builder = req_builder.query(&[("createdAfterExpression", &s.to_string())]);
        }
        if let Some(ref s) = created_before {
            req_builder = req_builder.query(&[("createdBefore", &s.to_string())]);
        }
        if let Some(ref s) = created_before_expression {
            req_builder = req_builder.query(&[("createdBeforeExpression", &s.to_string())]);
        }
        if let Some(ref s) = delegation_state {
            req_builder = req_builder.query(&[("delegationState", &s.to_string())]);
        }
        if let Some(ref s) = candidate_groups {
            req_builder = req_builder.query(&[("candidateGroups", &s.to_string())]);
        }
        if let Some(ref s) = candidate_groups_expression {
            req_builder = req_builder.query(&[("candidateGroupsExpression", &s.to_string())]);
        }
        if let Some(ref s) = with_candidate_groups {
            req_builder = req_builder.query(&[("withCandidateGroups", &s.to_string())]);
        }
        if let Some(ref s) = without_candidate_groups {
            req_builder = req_builder.query(&[("withoutCandidateGroups", &s.to_string())]);
        }
        if let Some(ref s) = with_candidate_users {
            req_builder = req_builder.query(&[("withCandidateUsers", &s.to_string())]);
        }
        if let Some(ref s) = without_candidate_users {
            req_builder = req_builder.query(&[("withoutCandidateUsers", &s.to_string())]);
        }
        if let Some(ref s) = active {
            req_builder = req_builder.query(&[("active", &s.to_string())]);
        }
        if let Some(ref s) = suspended {
            req_builder = req_builder.query(&[("suspended", &s.to_string())]);
        }
        if let Some(ref s) = task_variables {
            req_builder = req_builder.query(&[("taskVariables", &s.to_string())]);
        }
        if let Some(ref s) = process_variables {
            req_builder = req_builder.query(&[("processVariables", &s.to_string())]);
        }
        if let Some(ref s) = case_instance_variables {
            req_builder = req_builder.query(&[("caseInstanceVariables", &s.to_string())]);
        }
        if let Some(ref s) = variable_names_ignore_case {
            req_builder = req_builder.query(&[("variableNamesIgnoreCase", &s.to_string())]);
        }
        if let Some(ref s) = variable_values_ignore_case {
            req_builder = req_builder.query(&[("variableValuesIgnoreCase", &s.to_string())]);
        }
        if let Some(ref s) = parent_task_id {
            req_builder = req_builder.query(&[("parentTaskId", &s.to_string())]);
        }
        if let Some(ref s) = sort_by {
            req_builder = req_builder.query(&[("sortBy", &s.to_string())]);
        }
        if let Some(ref s) = sort_order {
            req_builder = req_builder.query(&[("sortOrder", &s.to_string())]);
        }
        if let Some(ref s) = first_result {
            req_builder = req_builder.query(&[("firstResult", &s.to_string())]);
        }
        if let Some(ref s) = max_results {
            req_builder = req_builder.query(&[("maxResults", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn get_tasks_count(&self, process_instance_id: Option<&str>, process_instance_id_in: Option<&str>, process_instance_business_key: Option<&str>, process_instance_business_key_expression: Option<&str>, process_instance_business_key_in: Option<&str>, process_instance_business_key_like: Option<&str>, process_instance_business_key_like_expression: Option<&str>, process_definition_id: Option<&str>, process_definition_key: Option<&str>, process_definition_key_in: Option<&str>, process_definition_name: Option<&str>, process_definition_name_like: Option<&str>, execution_id: Option<&str>, case_instance_id: Option<&str>, case_instance_business_key: Option<&str>, case_instance_business_key_like: Option<&str>, case_definition_id: Option<&str>, case_definition_key: Option<&str>, case_definition_name: Option<&str>, case_definition_name_like: Option<&str>, case_execution_id: Option<&str>, activity_instance_id_in: Option<&str>, tenant_id_in: Option<&str>, without_tenant_id: Option<bool>, assignee: Option<&str>, assignee_expression: Option<&str>, assignee_like: Option<&str>, assignee_like_expression: Option<&str>, assignee_in: Option<&str>, owner: Option<&str>, owner_expression: Option<&str>, candidate_group: Option<&str>, candidate_group_expression: Option<&str>, candidate_user: Option<&str>, candidate_user_expression: Option<&str>, include_assigned_tasks: Option<bool>, involved_user: Option<&str>, involved_user_expression: Option<&str>, assigned: Option<bool>, unassigned: Option<bool>, task_definition_key: Option<&str>, task_definition_key_in: Option<&str>, task_definition_key_like: Option<&str>, name: Option<&str>, name_not_equal: Option<&str>, name_like: Option<&str>, name_not_like: Option<&str>, description: Option<&str>, description_like: Option<&str>, priority: Option<i32>, max_priority: Option<i32>, min_priority: Option<i32>, due_date: Option<&str>, due_date_expression: Option<&str>, due_after: Option<&str>, due_after_expression: Option<&str>, due_before: Option<&str>, due_before_expression: Option<&str>, follow_up_date: Option<&str>, follow_up_date_expression: Option<&str>, follow_up_after: Option<&str>, follow_up_after_expression: Option<&str>, follow_up_before: Option<&str>, follow_up_before_expression: Option<&str>, follow_up_before_or_not_existent: Option<&str>, follow_up_before_or_not_existent_expression: Option<&str>, created_on: Option<&str>, created_on_expression: Option<&str>, created_after: Option<&str>, created_after_expression: Option<&str>, created_before: Option<&str>, created_before_expression: Option<&str>, delegation_state: Option<&str>, candidate_groups: Option<&str>, candidate_groups_expression: Option<&str>, with_candidate_groups: Option<bool>, without_candidate_groups: Option<bool>, with_candidate_users: Option<bool>, without_candidate_users: Option<bool>, active: Option<bool>, suspended: Option<bool>, task_variables: Option<&str>, process_variables: Option<&str>, case_instance_variables: Option<&str>, variable_names_ignore_case: Option<bool>, variable_values_ignore_case: Option<bool>, parent_task_id: Option<&str>) -> Result<crate::models::CountResultDto, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/task/count", configuration.base_path);
        let mut req_builder = client.get(uri_str.as_str());

        if let Some(ref s) = process_instance_id {
            req_builder = req_builder.query(&[("processInstanceId", &s.to_string())]);
        }
        if let Some(ref s) = process_instance_id_in {
            req_builder = req_builder.query(&[("processInstanceIdIn", &s.to_string())]);
        }
        if let Some(ref s) = process_instance_business_key {
            req_builder = req_builder.query(&[("processInstanceBusinessKey", &s.to_string())]);
        }
        if let Some(ref s) = process_instance_business_key_expression {
            req_builder = req_builder.query(&[("processInstanceBusinessKeyExpression", &s.to_string())]);
        }
        if let Some(ref s) = process_instance_business_key_in {
            req_builder = req_builder.query(&[("processInstanceBusinessKeyIn", &s.to_string())]);
        }
        if let Some(ref s) = process_instance_business_key_like {
            req_builder = req_builder.query(&[("processInstanceBusinessKeyLike", &s.to_string())]);
        }
        if let Some(ref s) = process_instance_business_key_like_expression {
            req_builder = req_builder.query(&[("processInstanceBusinessKeyLikeExpression", &s.to_string())]);
        }
        if let Some(ref s) = process_definition_id {
            req_builder = req_builder.query(&[("processDefinitionId", &s.to_string())]);
        }
        if let Some(ref s) = process_definition_key {
            req_builder = req_builder.query(&[("processDefinitionKey", &s.to_string())]);
        }
        if let Some(ref s) = process_definition_key_in {
            req_builder = req_builder.query(&[("processDefinitionKeyIn", &s.to_string())]);
        }
        if let Some(ref s) = process_definition_name {
            req_builder = req_builder.query(&[("processDefinitionName", &s.to_string())]);
        }
        if let Some(ref s) = process_definition_name_like {
            req_builder = req_builder.query(&[("processDefinitionNameLike", &s.to_string())]);
        }
        if let Some(ref s) = execution_id {
            req_builder = req_builder.query(&[("executionId", &s.to_string())]);
        }
        if let Some(ref s) = case_instance_id {
            req_builder = req_builder.query(&[("caseInstanceId", &s.to_string())]);
        }
        if let Some(ref s) = case_instance_business_key {
            req_builder = req_builder.query(&[("caseInstanceBusinessKey", &s.to_string())]);
        }
        if let Some(ref s) = case_instance_business_key_like {
            req_builder = req_builder.query(&[("caseInstanceBusinessKeyLike", &s.to_string())]);
        }
        if let Some(ref s) = case_definition_id {
            req_builder = req_builder.query(&[("caseDefinitionId", &s.to_string())]);
        }
        if let Some(ref s) = case_definition_key {
            req_builder = req_builder.query(&[("caseDefinitionKey", &s.to_string())]);
        }
        if let Some(ref s) = case_definition_name {
            req_builder = req_builder.query(&[("caseDefinitionName", &s.to_string())]);
        }
        if let Some(ref s) = case_definition_name_like {
            req_builder = req_builder.query(&[("caseDefinitionNameLike", &s.to_string())]);
        }
        if let Some(ref s) = case_execution_id {
            req_builder = req_builder.query(&[("caseExecutionId", &s.to_string())]);
        }
        if let Some(ref s) = activity_instance_id_in {
            req_builder = req_builder.query(&[("activityInstanceIdIn", &s.to_string())]);
        }
        if let Some(ref s) = tenant_id_in {
            req_builder = req_builder.query(&[("tenantIdIn", &s.to_string())]);
        }
        if let Some(ref s) = without_tenant_id {
            req_builder = req_builder.query(&[("withoutTenantId", &s.to_string())]);
        }
        if let Some(ref s) = assignee {
            req_builder = req_builder.query(&[("assignee", &s.to_string())]);
        }
        if let Some(ref s) = assignee_expression {
            req_builder = req_builder.query(&[("assigneeExpression", &s.to_string())]);
        }
        if let Some(ref s) = assignee_like {
            req_builder = req_builder.query(&[("assigneeLike", &s.to_string())]);
        }
        if let Some(ref s) = assignee_like_expression {
            req_builder = req_builder.query(&[("assigneeLikeExpression", &s.to_string())]);
        }
        if let Some(ref s) = assignee_in {
            req_builder = req_builder.query(&[("assigneeIn", &s.to_string())]);
        }
        if let Some(ref s) = owner {
            req_builder = req_builder.query(&[("owner", &s.to_string())]);
        }
        if let Some(ref s) = owner_expression {
            req_builder = req_builder.query(&[("ownerExpression", &s.to_string())]);
        }
        if let Some(ref s) = candidate_group {
            req_builder = req_builder.query(&[("candidateGroup", &s.to_string())]);
        }
        if let Some(ref s) = candidate_group_expression {
            req_builder = req_builder.query(&[("candidateGroupExpression", &s.to_string())]);
        }
        if let Some(ref s) = candidate_user {
            req_builder = req_builder.query(&[("candidateUser", &s.to_string())]);
        }
        if let Some(ref s) = candidate_user_expression {
            req_builder = req_builder.query(&[("candidateUserExpression", &s.to_string())]);
        }
        if let Some(ref s) = include_assigned_tasks {
            req_builder = req_builder.query(&[("includeAssignedTasks", &s.to_string())]);
        }
        if let Some(ref s) = involved_user {
            req_builder = req_builder.query(&[("involvedUser", &s.to_string())]);
        }
        if let Some(ref s) = involved_user_expression {
            req_builder = req_builder.query(&[("involvedUserExpression", &s.to_string())]);
        }
        if let Some(ref s) = assigned {
            req_builder = req_builder.query(&[("assigned", &s.to_string())]);
        }
        if let Some(ref s) = unassigned {
            req_builder = req_builder.query(&[("unassigned", &s.to_string())]);
        }
        if let Some(ref s) = task_definition_key {
            req_builder = req_builder.query(&[("taskDefinitionKey", &s.to_string())]);
        }
        if let Some(ref s) = task_definition_key_in {
            req_builder = req_builder.query(&[("taskDefinitionKeyIn", &s.to_string())]);
        }
        if let Some(ref s) = task_definition_key_like {
            req_builder = req_builder.query(&[("taskDefinitionKeyLike", &s.to_string())]);
        }
        if let Some(ref s) = name {
            req_builder = req_builder.query(&[("name", &s.to_string())]);
        }
        if let Some(ref s) = name_not_equal {
            req_builder = req_builder.query(&[("nameNotEqual", &s.to_string())]);
        }
        if let Some(ref s) = name_like {
            req_builder = req_builder.query(&[("nameLike", &s.to_string())]);
        }
        if let Some(ref s) = name_not_like {
            req_builder = req_builder.query(&[("nameNotLike", &s.to_string())]);
        }
        if let Some(ref s) = description {
            req_builder = req_builder.query(&[("description", &s.to_string())]);
        }
        if let Some(ref s) = description_like {
            req_builder = req_builder.query(&[("descriptionLike", &s.to_string())]);
        }
        if let Some(ref s) = priority {
            req_builder = req_builder.query(&[("priority", &s.to_string())]);
        }
        if let Some(ref s) = max_priority {
            req_builder = req_builder.query(&[("maxPriority", &s.to_string())]);
        }
        if let Some(ref s) = min_priority {
            req_builder = req_builder.query(&[("minPriority", &s.to_string())]);
        }
        if let Some(ref s) = due_date {
            req_builder = req_builder.query(&[("dueDate", &s.to_string())]);
        }
        if let Some(ref s) = due_date_expression {
            req_builder = req_builder.query(&[("dueDateExpression", &s.to_string())]);
        }
        if let Some(ref s) = due_after {
            req_builder = req_builder.query(&[("dueAfter", &s.to_string())]);
        }
        if let Some(ref s) = due_after_expression {
            req_builder = req_builder.query(&[("dueAfterExpression", &s.to_string())]);
        }
        if let Some(ref s) = due_before {
            req_builder = req_builder.query(&[("dueBefore", &s.to_string())]);
        }
        if let Some(ref s) = due_before_expression {
            req_builder = req_builder.query(&[("dueBeforeExpression", &s.to_string())]);
        }
        if let Some(ref s) = follow_up_date {
            req_builder = req_builder.query(&[("followUpDate", &s.to_string())]);
        }
        if let Some(ref s) = follow_up_date_expression {
            req_builder = req_builder.query(&[("followUpDateExpression", &s.to_string())]);
        }
        if let Some(ref s) = follow_up_after {
            req_builder = req_builder.query(&[("followUpAfter", &s.to_string())]);
        }
        if let Some(ref s) = follow_up_after_expression {
            req_builder = req_builder.query(&[("followUpAfterExpression", &s.to_string())]);
        }
        if let Some(ref s) = follow_up_before {
            req_builder = req_builder.query(&[("followUpBefore", &s.to_string())]);
        }
        if let Some(ref s) = follow_up_before_expression {
            req_builder = req_builder.query(&[("followUpBeforeExpression", &s.to_string())]);
        }
        if let Some(ref s) = follow_up_before_or_not_existent {
            req_builder = req_builder.query(&[("followUpBeforeOrNotExistent", &s.to_string())]);
        }
        if let Some(ref s) = follow_up_before_or_not_existent_expression {
            req_builder = req_builder.query(&[("followUpBeforeOrNotExistentExpression", &s.to_string())]);
        }
        if let Some(ref s) = created_on {
            req_builder = req_builder.query(&[("createdOn", &s.to_string())]);
        }
        if let Some(ref s) = created_on_expression {
            req_builder = req_builder.query(&[("createdOnExpression", &s.to_string())]);
        }
        if let Some(ref s) = created_after {
            req_builder = req_builder.query(&[("createdAfter", &s.to_string())]);
        }
        if let Some(ref s) = created_after_expression {
            req_builder = req_builder.query(&[("createdAfterExpression", &s.to_string())]);
        }
        if let Some(ref s) = created_before {
            req_builder = req_builder.query(&[("createdBefore", &s.to_string())]);
        }
        if let Some(ref s) = created_before_expression {
            req_builder = req_builder.query(&[("createdBeforeExpression", &s.to_string())]);
        }
        if let Some(ref s) = delegation_state {
            req_builder = req_builder.query(&[("delegationState", &s.to_string())]);
        }
        if let Some(ref s) = candidate_groups {
            req_builder = req_builder.query(&[("candidateGroups", &s.to_string())]);
        }
        if let Some(ref s) = candidate_groups_expression {
            req_builder = req_builder.query(&[("candidateGroupsExpression", &s.to_string())]);
        }
        if let Some(ref s) = with_candidate_groups {
            req_builder = req_builder.query(&[("withCandidateGroups", &s.to_string())]);
        }
        if let Some(ref s) = without_candidate_groups {
            req_builder = req_builder.query(&[("withoutCandidateGroups", &s.to_string())]);
        }
        if let Some(ref s) = with_candidate_users {
            req_builder = req_builder.query(&[("withCandidateUsers", &s.to_string())]);
        }
        if let Some(ref s) = without_candidate_users {
            req_builder = req_builder.query(&[("withoutCandidateUsers", &s.to_string())]);
        }
        if let Some(ref s) = active {
            req_builder = req_builder.query(&[("active", &s.to_string())]);
        }
        if let Some(ref s) = suspended {
            req_builder = req_builder.query(&[("suspended", &s.to_string())]);
        }
        if let Some(ref s) = task_variables {
            req_builder = req_builder.query(&[("taskVariables", &s.to_string())]);
        }
        if let Some(ref s) = process_variables {
            req_builder = req_builder.query(&[("processVariables", &s.to_string())]);
        }
        if let Some(ref s) = case_instance_variables {
            req_builder = req_builder.query(&[("caseInstanceVariables", &s.to_string())]);
        }
        if let Some(ref s) = variable_names_ignore_case {
            req_builder = req_builder.query(&[("variableNamesIgnoreCase", &s.to_string())]);
        }
        if let Some(ref s) = variable_values_ignore_case {
            req_builder = req_builder.query(&[("variableValuesIgnoreCase", &s.to_string())]);
        }
        if let Some(ref s) = parent_task_id {
            req_builder = req_builder.query(&[("parentTaskId", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn handle_bpmn_error(&self, id: &str, task_bpmn_error_dto: Option<crate::models::TaskBpmnErrorDto>) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/task/{id}/bpmnError", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        req_builder = req_builder.json(&task_bpmn_error_dto);

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn handle_escalation(&self, id: &str, task_escalation_dto: Option<crate::models::TaskEscalationDto>) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/task/{id}/bpmnEscalation", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        req_builder = req_builder.json(&task_escalation_dto);

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn query_tasks(&self, first_result: Option<i32>, max_results: Option<i32>, task_query_dto: Option<crate::models::TaskQueryDto>) -> Result<Vec<crate::models::TaskDto>, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/task", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref s) = first_result {
            req_builder = req_builder.query(&[("firstResult", &s.to_string())]);
        }
        if let Some(ref s) = max_results {
            req_builder = req_builder.query(&[("maxResults", &s.to_string())]);
        }
        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        req_builder = req_builder.json(&task_query_dto);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn query_tasks_count(&self, task_query_dto: Option<crate::models::TaskQueryDto>) -> Result<crate::models::CountResultDto, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/task/count", configuration.base_path);
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        req_builder = req_builder.json(&task_query_dto);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn resolve(&self, id: &str, complete_task_dto: Option<crate::models::CompleteTaskDto>) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/task/{id}/resolve", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        req_builder = req_builder.json(&complete_task_dto);

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn set_assignee(&self, id: &str, user_id_dto: Option<crate::models::UserIdDto>) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/task/{id}/assignee", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        req_builder = req_builder.json(&user_id_dto);

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn submit(&self, id: &str, complete_task_dto: Option<crate::models::CompleteTaskDto>) -> Result<::std::collections::HashMap<String, crate::models::VariableValueDto>, Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/task/{id}/submit-form", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        req_builder = req_builder.json(&complete_task_dto);

        // send request
        let req = req_builder.build()?;

        Ok(client.execute(req)?.error_for_status()?.json()?)
    }

    fn unclaim(&self, id: &str) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/task/{id}/unclaim", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.post(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

    fn update_task(&self, id: &str, task_dto: Option<crate::models::TaskDto>) -> Result<(), Error> {
        let configuration: &configuration::Configuration = self.configuration.borrow();
        let client = &configuration.client;

        let uri_str = format!("{}/task/{id}", configuration.base_path, id=crate::apis::urlencode(id));
        let mut req_builder = client.put(uri_str.as_str());

        if let Some(ref user_agent) = configuration.user_agent {
            req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
        }
        req_builder = req_builder.json(&task_dto);

        // send request
        let req = req_builder.build()?;

        client.execute(req)?.error_for_status()?;
        Ok(())
    }

}
